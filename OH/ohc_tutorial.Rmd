---
title: "DOHC"
output: 
  bookdown::html_document2:
    base_format: rmarkdown::html_vignette
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{DOHC}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
# Mapping Ocean Heat Content from Synthetic Observations in Indian Ocean

## Loading Data
Here we load the Indian ocean shapefile. We smooth the boundary to make the mesh creation easier. 
```{r}
# Only for the first time 
# fdmr::retrieve_tutorial_data(dataset = "indian_ocean")
# fdmr::load_tutorial_data(dataset = "indian_ocean", 
#                          filename = "indian_ocean.rds")
ocean_sf <-
  st_read(here::here("OH","indian_ocean.shp"))
# ocean_sf <- ocean_sf[as.numeric(st_area(ocean_sf)) > 50000]
ocean_crs <- fm_crs(ocean_sf) 
fm_crs(ocean_sf) <- NULL
ocean_sf2 <- st_union(st_buffer(ocean_sf, 1.05))
```

We plot the Indian ocean to check if there is any issues. 
```{r}
ggplot() + geom_sf(data=ocean_sf2)

```

We convert into a sp object.
```{r}
fm_crs(ocean_sf) <- ocean_crs
ocean_sp <- as_Spatial(ocean_sf)
```

We regularly sample some points (20$\times$20) to put in the mesh builder function under the fdmr package to get a feeling of the parameter setting for the mesh.
```{r}
ocean_pts <- st_sample(ocean_sf, size = 20*20,
                       type = "regular")

ocean_pts_sp <- as_Spatial(ocean_pts)

colnames(ocean_pts_sp@coords) <- c("LONG", "LAT")
```

Here comes the mesh_builder function. We set the max edge and offset a bit larger to cater the computation. 
```{r}
fdmr::mesh_builder(spatial_data = as.data.frame(ocean_pts_sp),
                   max_edge = c(50,100),
                   offset = c(50,100),
                   # crs = fm_crs(ocean_pts_sp),
                   cutoff = 1)
```

We create the outer boundary. 
```{r}
ocean_bnd <- st_cast(
  st_sf(geometry = fm_nonconvex_hull(ocean_sf2, 5)),
  "POLYGON"
)
```

We create the mesh for the Indian ocean with the outer boundary.
We remove Sri Lanka and keep Madagasikara in the cutoff. We might do a Barrier model on a sphere in the future.  
```{r}
boundary <- fm_as_segm_list(list(ocean_sf2, ocean_bnd))

mesh <- fm_mesh_2d_inla(boundary = boundary,
                        max.edge = c(5, 7),
                        offset = c(3, 3),
                        cutoff = 1)

ggplot() + geom_sf(data = ocean_sf2) + gg(mesh)
```

## Model

We considered one year of top layer DOHC (between 0 and 306.25 m depth) in 2005. Observations are indexed by the month of occurrence, resulting in 12 indices, which is equal to the number of time points. To pass the data to the function, we created a `SpatialPolygonsDataFrame` from a `data.frame`.
```{r}
# Transform latitudes and longtiudes to numeric
df_f$lat <- base::sapply(df_f$lat, as.numeric)
df_f$lon <- base::sapply(df_f$lon, as.numeric)

# Add sp coordinates
sp::coordinates(df_f) <- c('lon', 'lat')

# Determine the group size
n_time <- base::as.integer(base::length(base::unique(df_f@data$time)))

```
### Prior selection

To implement the SPDE approach, we defined the range un uncertainty priors. We assume that the probability of process spatial range (physically, a distance where correlation between two observations falls to 0.1) being under 25 degrees in latitude is 0.2. We also set the probability to 0.1 that the marginal standard deviation of the process exceeds 1.

The process is assumed to be evolving temporally as an autoregressive process of the first order (AR1) with the probability of the temporal autocorrelation parameter be over 0 is 0.9.

```{r}
prior_range <- 25
prior_Pgt <- 0.2
  
# Define the SPDE
ohc_spde <- INLA::inla.spde2.pcmatern(mesh, prior.range = c(prior_range, prior_Pgt), prior.sigma = c(1, 0.1))

# Define temporal parameter
rhoprior <- base::list(theta = base::list(prior = 'pccor1', param = c(0, 0.9)))
```

### Define the model formula

We use a spatio-temporal model with only random effects.
```{r}
model_formula <- dohc_L1 ~ -1 + f(
  main = coordinates,
  model = ohc_spde,
  group = time,
  ngroup = n_time,
  control.group = list(
    model = 'ar1',
    hyper = rhoprior
  )
)
```

### Fit the model

```{r}
bru_model <- inlabru::bru(model_formula,
                          data = df_f,
                          family = "gaussian",
                          options = list(
                            verbose = TRUE,
                            bru_verbose = 4
                          )
)
```

## Output
